### 1. Her yaml dosyası 4 ana bileşenden oluşur.

``` 
apiVersion: hangi api versionuyla tanımlanacak.
kind:       hangi tür obje oluşturulacak
metadata:   unig bilgileri tanımlarız.İsim gibi
spec:       objenin özelliklerini belirleme
``` 

- objectbasetemplate.yaml
``` 
apiVersion: v1
kind: Pod
metadata:
  name: firstpod
  labels:
    app: front-end
    team: developer

spec:
  containers:
  - name: nginx 
    image: nginx:latest
    ports:
    - containerPort: 80
``` 

``` 
kubectl apply -f pod1.yaml
``` 

``` 
kubectl describe pods firstpod
``` 

### 2. Pod Yaşam döngüsü

- Always : Container içindeki uygulama bir şekilde kapanırsa her zamana tekrardan çalışması komutu.
- On-failure: hata alıp kapanırdsa yeniiden çalışır
- Never : Hiç bir zaman başlamaz

``` 
Pending : Pod ile ilgili bilgiler kaydedildi ancak oluşturulmadı.
Creating : Kube scheduler üretim için node ayarlar uygun node bulamamış ise yaratma olmaz
İmagePullBackOff : Kubelet oluşturamayınca olan hata
Running : Kubelet container yapma süreci
Succeeded : Başarılı şekilde başlamış
Failed : Başarılı olmamışsa
CrashLoopBackOff : Container sık sık kapanıuorsa container çalışma durumu bunu gösterir.
``` 

### 3. Çoklu Container
- Nginx imajedan oluşan bir web sayfası oluşturulacak
- 2. container web ile ilgili bilgilerin bulunduğu github deposundan bilgileri alacak ve volume kaydedecek
- Nginx de aynı volume bağlı olduğu için burdaki bilgileri okuyarak web i güncelleyecek 

-podmulticontainer.yaml

``` 
apiVersion: v1
kind: Pod
metadata:
  name: multicontainer
spec:
  containers:
  - name: webcontainer
    image: nginx
    ports:
      - containerPort: 80
    volumeMounts:
    - name: sharedvolume
      mountPath: /usr/share/nginx/html
  - name: sidecarcontainer
    image: busybox
    command: ["/bin/sh"]
    args: ["-c", "while true; do wget -O /var/log/index.html https://raw.githubusercontent.com/ozgurozturknet/hello-world/master/index.html; sleep 15; done"]
    volumeMounts:
    - name: sharedvolume
      mountPath: /var/log
  volumes:
  - name: sharedvolume
    emptyDir: {}

``` 

```
kubectl apply -f podmulticontainer.yaml
```

```
kubectl get pods
```

```
kubectl port-forward pod/multicontainer 8080:80
```


### 4. Inıt Container

- Bir container çalışmadan diğer container çalışmaz

```
apiVersion: v1
kind: Pod
metadata:
  name: initcontainerpod
spec:
  containers:
  - name: appcontainer
    image: busybox
    command: ['sh', '-c', 'echo The app is running! && sleep 3600']
  initContainers:
  - name: initcontainer
    image: busybox
    command: ['sh', '-c', "until nslookup myservice; do echo waiting for myservice; sleep 2; done"]
    
```

```
kubectl apply -f podinitcontainer.yaml
```

### 5. Label ve Selector

- Etiketler ve etiket seçimleri ile oluşturdugumuz objelere anlayacağımız bilgiler ekliyoruz.
- Etiketler obje oluşturuken kurulur veya obje oluşturulduktan sonra.
- Kubernets de bağlantılar etiketler sayesinde olur

```
apiVersion: v1
kind: Pod
metadata:
  name: pod1
  labels:
    app: firstapp
    tier: frontend
    mycluster.local/team: team1
spec:
  containers:
  - name: nginx
    image: nginx:latest
    ports:
    - containerPort: 80
---
apiVersion: v1
kind: Pod
metadata:
  name: pod2
  labels:
    app: firstapp
    tier: frontend
spec:
  containers:
  - name: nginx
    image: nginx:latest
    ports:
    - containerPort: 80
---
apiVersion: v1
kind: Pod
metadata:
  name: pod3
  labels:
    app: firstapp
    tier: backend
spec:
  containers:
  - name: nginx
    image: nginx:latest
    ports:
    - containerPort: 80
---
apiVersion: v1
kind: Pod
metadata:
  name: pod4
  labels:
    app: firstapp
    tier: backend
spec:
  containers:
  - name: nginx
    image: nginx:latest
    ports:
    - containerPort: 80
---
apiVersion: v1
kind: Pod
metadata:
  name: pod5
  labels:
    app: secondapp
    tier: frontend
spec:
  containers:
  - name: nginx
    image: nginx:latest
    ports:
    - containerPort: 80
---
apiVersion: v1
kind: Pod
metadata:
  name: pod6
  labels:
    app: secondapp
    tier: frontend
spec:
  containers:
  - name: nginx
    image: nginx:latest
    ports:
    - containerPort: 80
---
apiVersion: v1
kind: Pod
metadata:
  name: pod7
  labels:
    app: secondapp
    tier: backend
spec:
  containers:
  - name: nginx
    image: nginx:latest
    ports:
    - containerPort: 80
---
apiVersion: v1
kind: Pod
metadata:
  name: pod8
  labels:
    app: secondapp
    tier: backend
spec:
  containers:
  - name: nginx
    image: nginx:latest
    ports:
    - containerPort: 80
---
apiVersion: v1
kind: Pod
metadata:
  name: pod9
  labels:
    team: team1
spec:
  containers:
  - name: nginx
    image: nginx:latest
    ports:
    - containerPort: 80
---
apiVersion: v1
kind: Pod
metadata:
  name: pod10
  labels:
    team: team2
spec:
  containers:
  - name: nginx
    image: nginx:latest
    ports:
    - containerPort: 80
---
apiVersion: v1
kind: Pod
metadata:
  name: pod11
spec:
  containers:
  - name: nginx
    image: nginx:latest
    ports:
    - containerPort: 80
  nodeSelector:
    hddtype: ssd
```

- app isimli etiketler 
```
kubectl get pods -l “app” --show-labels
```

- app etiketi belirliyorum
```
kubectl get pods -l “app=firstapp” --show-labels
```

- birden fazla etiket giriyorum bunu virgül ile yapıyorum
```
kubectl get pods -l “app=firstapp, tier=frontend” –show-labels
```

- birden fazla etiket giriyorum
```
kubectl get pods -l “app=firstapp, tier!=frontend” –show-labels
```

- farklı bir biçimde etiket tanımlama
```
kubectl get pods -l ‘app in (firstapp)’ --show-labels
kubectl get pods -l ‘app in (firstapp,secondapp)’ --show-labels
```

-app firstapp olarak antanmamışları listele
```
kubectl get pods -l ‘app notin (firstapp)’ --show-labels
```

- app anahtarına sahip olcak ve firstapp olarak atanmamaışları getir
```
kubectl get pods -l ‘app, app notin (firstapp)’ --show-labels
```

- app anahtrarına sahip olmayanları bul
```
kubectl get pods -l ‘!app’ --show-labels
```

- app anahtarı atanmış tier değeri frontend olmayanları bulmasını istiyorouz
```
kubectl get pods -l “app in (firstapp), tier notin(frontend)” --show-labels
```

- Sonradan etiket ekleme

```
kubectl get pods --show-labels
kubectl label pods pod9 app=thirdapp
```

- Etiket silme
```
kubectl label pods pod9 app-
```

- Etiket güncelleme
```
kubectl label --overwrite pods pod9 team=team3
kubectl get pods --show-labels
```

- Objeler arasında ilişki kurmak
```
kubectl label nodes minikube hddtype=ssd
```

### 6. Annotation

- Objeye onu tanımlayan fakat label olarak eklememizin sakıncalı olacağı bilgileri annotation "açıklama" olarak ekleriz.

- Prefix "örnek" kısmı opsiyoneldir. Zorunlu değildir.

- Alfanumerik bir karakterle ([a-z0-9 A-Z]) başlamalı ve bitmelidir.

- Tire (-), alt çizgi (_), noktalar (.) ve arasında alfanumerik değerler içerebilir.

- Değer alanında bu kurallar geçerli değildir. Alfanümerik olmayan karakter de alabilir.

```
apiVersion: v1
kind: Pod
metadata:
  name: annotationpod
  annotations:
    owner: "Ozgur OZTURK"
    notification-email: "admin@k8sfundamentals.com"
    releasedate: "01.01.2021"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
spec:
  containers:
  - name: annotationcontainer
    image: nginx
    ports:
    - containerPort: 80

```    

```
kubectl apply -f podannotation.yaml
```

```
kubectl describe pod annotationpod
```

- Ekleme
```
kubectl annotate pods annotationpod foo=bar
```

- Silme
```
kubectl annotate pods annotationpod foo-
```


### 7. Names Space

- 10 kişinin dosya paylaşacağı bir sistem nasıl kurarım.

```
Namespaceler adlar için bir kapsam sağlar. 
Kaynak adlarının bir namespace içinde benzersiz olması gerekir. 
Namespace birbirinin içine yerleştirilemez ve her Kubernetes kaynağı yalnızca bir namespace içinde olabilir.
```

```
Namespaceler cluster kaynaklarını birden çok kullanıcı arasında bölmenin bir yoludur.
kubectl get namespaces
```

- default : aksini belirtmediğimiz sürece objeler burda oluşturulur.
- kube-node-lease :özel işlemleri içeren namespacedir.
- kube-public : Kimliği doğrulanmamış olanlar dahil tüm kullanıcıların erişebileceği yerdir
- kube-system : Kubernets tarafından oluşturulan objelerin oluşturulduğu namespacdir.


Yeni bir name space oluşturma
```
kubectl create namespace app1
```

Namespceleri sıralama
```
kubectl get namespace
```

```
apiVersion: v1
kind: Namespace
metadata:
  name: development
---
apiVersion: v1
kind: Pod
metadata:
  namespace: development
  name: namespacepod
spec:
  containers:
  - name: namespacecontainer
    image: nginx:latest
    ports:
    - containerPort: 80
```

```
kubectl get namespace
```

```
kubectl create namespace app1
```

```
kubectl apply -f podnamespace.yaml
```

```
kubectl get pods -n development
```

İletişim kuracağımız obje ile iletişim kurmak istiyorsak namespace belirtmeliyiz.
```
kubectl exec -it namespacedpod -n development -- /bin/sh
```


Varsıyalan değerini değiştirmek istiyorsak
```
kubectl config set-ccontext --current --namespce=development
kubectl get pods
```

namespace silme
```
kubectl delete namespces development 
```

### 8. Deployment
- Uygulamamızı imaj haline getirir ve pod olarak deploy ederiz.
- Kubernets de podlar genellikle singel olarak yaratılmaz.
- Podları yöneten üst seviye bir obje yaratırırz ve podlar bu objeler tarafından yaratılıp yönetilir.
- Bu üst seviye objelerden biride "deployment" dır.


- Bir Deployment'da istenen durumu tanımlarsınız ve Deployment Controller, mevcut durumu istenilen durumla karşılaştırıp gerekli aksiyonları alır.

```
kubectl create deployment firstdeployment --image=nginx:latest --replicas=2
```

```
kubectl get deployment
```

-deployment güncelleme
```
kubectl set image deployment/firstdeployment nginx=httpd 
```

-pod sayısını ayarlama
```
kubectl scale deployment firstdeployment --replicas=5
```

- deployment silme
```
kubectl delete deployments firstdeployment
```

- deployment.yaml version 1
```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: firstdeployment
  labels:
    team: development
spec:
  replicas: 3
  selector:
    matchLabels:
      app: frontend
  template:
```

- matchLabels: Lable ile hangi imaje deploye edeceğini öğrenir.
- selector kısmında "frontend" ile bilgi veriyorum.
- template kısmında "frontend" ile bu pod bilgilerini kullan diyorum

- deployment.yaml version 2
```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: firstdeployment  
  labels:
    team: development
spec:
  replicas: 3            
  selector:
    matchLabels:
      app: frontend
  template:              
    metadata:
      labels:
        app: frontend
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80
```

```
kubectl get pods
```

### 9. Replicaset

- Deployment replicaset oluşturur replicaset deploymenta belirtilen özelliklere göre pod oluşturur.
- Bir ReplicaSet'in amacı, herhangi bir zamanda çalışan kararlı bir replika Pod setini sürdürmektir. 
- Bu nedenle, genellikle belirli sayıda özdeş Pod'un kullanılabilirliğini garanti etmek için kullanılır.

- rs.yaml
```
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: firstrs
  labels:
    app: rs
spec:
  replicas: 3
  selector:
    matchLabels:
      app: rs
  template:
    metadata:
      labels:
        app: rs
    spec:
      containers:
      - name: nginx
        image: nginx
```


```
kubectl apply -f rs.yaml
```

```
kubectl get replicaset
```

```
kubectl delete rs firstrs
```


### 9.2. Rollout - Recreat

- recreat: Bu deploymenta bir değişiklik yaparsam öncelikle tüm mevcut kodları sil ve bu işlem tamamlandıktan sonra yeni podları oluşturur.

```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rcdeployment
  labels:
    team: development
spec:
  replicas: 3
  selector:
    matchLabels:
      app: recreate
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: recreate
    spec:
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 80
```

```
kubectl apply -f deployrolling.yaml --record
```

```
kubectl set image deployment deployrecreate.yaml nginx=httpd:alpine --record=ture 
```

```
kubectl set image deployment deployrecreate.yaml nginx=httpd:alpine --record=ture 
```

### 9.3 RollingUpdate

- RollingUpdate: Ben bir değişiklik yaptığım zaman tüm kodları silip yenisini oluşturma bunun yerine bu işi aşamalı olarak yap. 
```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rolldeployment
  labels:
    team: development
spec:
  replicas: 10
  selector:
    matchLabels:
      app: rolling
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 2
      maxSurge: 2
  template:
    metadata:
      labels:
        app: rolling
    spec:
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 80
```

```
kubectl apply -f deployrolling.yaml --record
```

- record yapılan değişikleri kayderder
```
kubectl set image deployment rolldeployment nginx=httpd:alpine --record=ture 
```

```
kubectl rollout history deployment rolldeployment
```

istediğim aralıktaki değişiklikleri göster
```
kubectl rollout history deployment rolldeployment --revision=2 
```

istediğim hale geri dönme
```
kubectl rollout undo deployment rolldeployment --to-revision=1
```

Yapılan işlemi durdurur.
```
kubectl rollout pause deployment status deployment rolldeployment -w
```

